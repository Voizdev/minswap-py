"""Standard models and model conversion functions.

This module contains common models used throughout minswap-py as well as utility
functions for converting data types.
"""

from collections.abc import Iterable
from typing import Any, Dict, List, Optional, Union

import pycardano
from blockfrost import Namespace
from pydantic import BaseModel, root_validator, validator

from minswap.models import blockfrost_models


def to_dict(
    values: Union[Namespace, List[Any], Dict[str, Any]]
) -> Union[List[Any], Dict[str, Any]]:
    """Traverse a dictionary and convert blockfrost.Namespace objects to dictionaries.

    When using `blockfrost.Namespace.to_dict` function to convert a `Namespace` object
    to a `dict`, child values that are `Namespace` objects are not converted to a
    `dict`. This function traverse a `Namespace`, `List`, or `Dict` and converts any
    child values from `Namespace` to `dict`. This is necessary for casting to
    `pydantic` models for proper error checking and validation.

    Traversel of the input is recursive, ensuring all children are converted.

    Args:
        values: A `Namespace`, `List`, or `Dict` to be recursively traversed.

    Returns:
        Union[List[Any], Dict[Any, Any], Dict[str, Any]]
    """
    iterator: Optional[Iterable] = None

    if isinstance(values, (Namespace)):
        values = values.to_dict()

    if isinstance(values, list):
        iterator = enumerate(values)
    elif isinstance(values, dict):
        iterator = values.items()

    if iterator is not None:
        for k, v in iterator:
            if isinstance(v, Namespace):
                values[k] = to_dict(v.to_dict())
            elif isinstance(v, (list, dict)):
                values[k] = to_dict(v)

        assert isinstance(values, (list, dict)), f"Error: {values}"

    return values


class BaseList(BaseModel):
    """Utility class for list models."""

    def __iter__(self):  # noqa
        return iter(self.__root__)

    def __getitem__(self, item):  # noqa
        return self.__root__[item]

    def __len__(self):  # noqa
        return len(self.__root__)


class BaseDict(BaseList):
    """Utility class for dict models."""

    def items(self):
        """Iterate of key-value pairs."""
        return self.__root__.items()


class TxIn(BaseModel):
    """A quantity of a blockchain asset."""

    tx_hash: str
    tx_index: int


def _unit_alias(unit: str) -> str:
    """Rename unit alias.

    If a unit alias is input, it changes it to "unit". Otherwise, passes the value
    through.

    Arg:
        unit: The unit alias, or passthrough.
    """
    if unit in ["asset"]:
        return "unit"
    else:
        return unit


class Quantity(BaseModel):
    """A quantity of a blockchain asset."""

    unit: str
    quantity: int

    class Config:  # noqa
        alias_generator = _unit_alias
        allow_mutation = False


class Value(BaseModel):
    """Contains all tokens and quantities."""

    __root__: List[Quantity]

    def __iter__(self):  # noqa
        return iter(self.__root__)

    def __getitem__(self, item):  # noqa
        return self.__root__[item]

    def __len__(self):  # noqa
        return len(self.__root__)


class Address(BaseModel):
    """A Cardano address.

    This class holds Cardano address information, including payment, stake, and script
    addresses. The input should be the `bech32` encoded address.
    """

    bech32: str
    address: pycardano.Address
    payment: Optional[pycardano.Address]
    stake: Optional[pycardano.Address]

    class Config:  # noqa: D106
        arbitrary_types_allowed = True

    @root_validator(pre=True)
    def translate_address(cls, values):  # noqa: D102
        assert "bech32" in values

        values["address"] = pycardano.Address.decode(values["bech32"])

        if values["address"].staking_part is not None:
            values["stake"] = pycardano.Address(
                staking_part=values["address"].staking_part
            )
        else:
            values["stake"] = None

        if values["address"].payment_part is not None:
            values["payment"] = pycardano.Address(
                payment_part=values["address"].payment_part
            )
        else:
            values["payment"] = None

        return values


class OnchainMetadata(blockfrost_models.AssetOnchainMetadataCip25):
    """Data class to hold on chain metadata for an asset."""

    _files_val = validator("files", pre=True, allow_reuse=True)(to_dict)


class Metadata(blockfrost_models.Metadata1):
    """Asset metadata.

    The blockfrost autogenerated model does not conform to the metadata asset definition
    for the cardano token registry, so this modifies it to be in compliance.

    https://developers.cardano.org/docs/native-tokens/cardano-token-registry/
    """

    decimals: Optional[int] = blockfrost_models.Metadata1.__fields__[
        "decimals"
    ]  # type: ignore
    logo: Optional[str] = blockfrost_models.Metadata1.__fields__["logo"]  # type: ignore
    ticker: Optional[str] = blockfrost_models.Metadata1.__fields__[
        "ticker"
    ]  # type: ignore
    url: Optional[str] = blockfrost_models.Metadata1.__fields__["url"]  # type: ignore


class AssetIdentity(blockfrost_models.Asset1):
    """A blockchain asset."""

    onchain_metadata: Optional[OnchainMetadata] = blockfrost_models.Asset1.__fields__[
        "onchain_metadata"
    ]  # type: ignore

    metadata: Optional[Metadata] = blockfrost_models.Asset1.__fields__[
        "metadata"
    ]  # type: ignore

    _onchain_metadata_val = validator("onchain_metadata", pre=True, allow_reuse=True)(
        to_dict
    )


class AddressUtxoContentItem(blockfrost_models.AddressUtxoContentItem):
    """An address UTxO item."""

    reference_script_hash: Optional[
        str
    ] = blockfrost_models.AddressUtxoContentItem.__fields__[
        "reference_script_hash"
    ]  # type: ignore

    inline_datum: Optional[str] = blockfrost_models.AddressUtxoContentItem.__fields__[
        "inline_datum"
    ]  # type: ignore

    data_hash: Optional[str] = blockfrost_models.AddressUtxoContentItem.__fields__[
        "inline_datum"
    ]  # type: ignore


class AddressUtxoContent(blockfrost_models.AddressUtxoContent):
    """An address UTxO list of items."""

    __root__: List[
        AddressUtxoContentItem
    ] = blockfrost_models.AddressUtxoContent.__fields__[
        "__root__"
    ]  # type:ignore

    def __iter__(self):  # noqa
        return iter(self.__root__)

    def __getitem__(self, item):  # noqa
        return self.__root__[item]

    def __len__(self):  # noqa
        return len(self.__root__)
